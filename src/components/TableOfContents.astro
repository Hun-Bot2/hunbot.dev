---
---

<!-- Compact TOC Button -->
<button id="toc-trigger" class="fixed top-20 right-6 bg-white dark:bg-slate-800 border border-slate-200 dark:border-slate-700 rounded-lg shadow-lg hover:shadow-xl transition-all duration-300 z-[60] flex items-center gap-2 px-3 py-2 group hover:bg-slate-50 dark:hover:bg-slate-700 cursor-pointer select-none">
	<svg class="w-4 h-4 text-slate-700 dark:text-slate-300 group-hover:text-slate-900 dark:group-hover:text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
		<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h7"/>
	</svg>
	<span class="text-sm font-medium text-slate-700 dark:text-slate-300 group-hover:text-slate-900 dark:group-hover:text-white hidden sm:block">
		목차
	</span>
	<span class="text-xs text-slate-500 dark:text-slate-400 block sm:hidden">
		목차
	</span>
	<!-- Arrow Icon -->
	<svg id="toc-arrow" class="w-3 h-3 text-slate-500 dark:text-slate-400 group-hover:text-slate-700 dark:group-hover:text-slate-300 transition-transform duration-300" fill="none" stroke="currentColor" viewBox="0 0 24 24">
		<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"/>
	</svg>
</button>

<!-- Compact TOC Panel -->
<div id="table-of-contents" class="fixed top-20 right-20 w-64 bg-white dark:bg-slate-800 border border-slate-200 dark:border-slate-700 rounded-lg shadow-xl max-h-[calc(100vh-6rem)] overflow-hidden z-[55] transition-all duration-300 opacity-0 scale-95 pointer-events-none">
	<div class="p-4 border-b border-slate-200 dark:border-slate-700">
		<h3 class="text-sm font-semibold text-slate-900 dark:text-slate-100 flex items-center gap-2">
			<svg class="w-4 h-4 text-blue-600 dark:text-blue-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
				<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h7"/>
			</svg>
			목차
		</h3>
	</div>
	<nav class="p-3 max-h-96 overflow-y-auto scrollbar-thin scrollbar-track-transparent scrollbar-thumb-slate-300 dark:scrollbar-thumb-slate-600">
		<ul id="toc-list" class="space-y-1">
		</ul>
	</nav>
</div>

<style>
	/* TOC Panel States */
	#table-of-contents.visible {
		@apply opacity-100 scale-100 pointer-events-auto;
	}
	
	/* Arrow Animation */
	#toc-trigger.active #toc-arrow {
		@apply rotate-180;
	}
	
	/* Dragging States */
	#toc-trigger.dragging {
		@apply cursor-grabbing shadow-2xl scale-105 z-50;
		transition: none !important;
	}
	
	#toc-trigger:active {
		@apply cursor-grabbing;
	}
	
	/* TOC Links */
	.toc-link {
		@apply block text-slate-600 dark:text-slate-400 no-underline px-3 py-1.5 rounded-lg text-xs leading-relaxed transition-all duration-200 hover:bg-slate-100 dark:hover:bg-slate-700 hover:text-slate-900 dark:hover:text-slate-100;
	}
	
	.toc-link.active {
		@apply bg-blue-50 dark:bg-blue-900/30 text-blue-700 dark:text-blue-300 font-medium border-l-2 border-blue-500 pl-2;
	}
	
	/* Heading Levels */
	.toc-h1 { @apply font-medium; }
	.toc-h2 { @apply pl-3; }
	.toc-h3 { @apply pl-6 text-[11px]; }
	.toc-h4 { @apply pl-9 text-[11px]; }
	.toc-h5 { @apply pl-12 text-[10px]; }
	.toc-h6 { @apply pl-14 text-[10px]; }
	
	/* Mobile Responsive */
	@media (max-width: 1023px) {
		#table-of-contents {
			@apply w-80 right-6 top-20;
		}
	}
	
	@media (max-width: 640px) {
		#toc-trigger {
			@apply px-2 py-1.5 top-20;
		}
		
		#table-of-contents {
			@apply w-[calc(100vw-3rem)] right-6 left-6 top-16;
		}
	}
	
	/* Custom Scrollbar */
	.scrollbar-thin::-webkit-scrollbar {
		width: 4px;
	}
	
	.scrollbar-thin::-webkit-scrollbar-track {
		background: transparent;
	}
	
	.scrollbar-thin::-webkit-scrollbar-thumb {
		@apply bg-slate-300 dark:bg-slate-600 rounded-full;
	}
	
	.scrollbar-thin::-webkit-scrollbar-thumb:hover {
		@apply bg-slate-400 dark:bg-slate-500;
	}
</style>

<script>
	document.addEventListener('DOMContentLoaded', function() {
		const tocTrigger = document.getElementById('toc-trigger');
		const tocContainer = document.getElementById('table-of-contents');
		const tocList = document.getElementById('toc-list');
		
		if (!tocTrigger || !tocContainer || !tocList) return;
		
		// Drag state
		let isDragging = false;
		let dragOffset = { x: 0, y: 0 };
		let currentPosition = { x: 0, y: 0 };
		let dragStarted = false;
		
		function updateTriggerPosition() {
			if (tocTrigger) {
				console.log('Updating TOC position:', currentPosition);
				tocTrigger.style.transform = `translate(${currentPosition.x}px, ${currentPosition.y}px)`;
			}
		}
		
		function constrainToViewport() {
			if (!tocTrigger) return;
			
			// Get viewport bounds
			const maxX = window.innerWidth - tocTrigger.offsetWidth - 24; // 24px margin
			const maxY = window.innerHeight - tocTrigger.offsetHeight - 24; // 24px margin
			
			// Constrain to viewport
			currentPosition.x = Math.max(0, Math.min(maxX, currentPosition.x));
			currentPosition.y = Math.max(0, Math.min(maxY, currentPosition.y));
		}
		
		// Load saved position with viewport bounds checking
		// SIMPLIFIED: Always use default position for reliability
		currentPosition = { x: 0, y: 0 };
		localStorage.removeItem('toc-position'); // Clear any saved data
		
		// Drag functionality
		function startDrag(e: MouseEvent) {
			if (!tocTrigger) return;
			
			dragStarted = false;
			isDragging = true;
			
			const rect = tocTrigger.getBoundingClientRect();
			dragOffset.x = e.clientX - rect.left;
			dragOffset.y = e.clientY - rect.top;
			
			tocTrigger.classList.add('dragging');
			document.addEventListener('mousemove', handleDrag);
			document.addEventListener('mouseup', endDrag);
			e.preventDefault();
		}
		
		function handleDrag(e: MouseEvent) {
			if (!tocTrigger || !isDragging) return;
			
			dragStarted = true; // Mark that we actually started dragging
			
			const newX = e.clientX - dragOffset.x;
			const newY = e.clientY - dragOffset.y;
			
			// Update position
			currentPosition.x = newX;
			currentPosition.y = newY;
			
			// Constrain to viewport
			constrainToViewport();
			
			updateTriggerPosition();
		}
		
		function endDrag() {
			if (!tocTrigger) return;
			
			tocTrigger.classList.remove('dragging');
			document.removeEventListener('mousemove', handleDrag);
			document.removeEventListener('mouseup', endDrag);
			
			// Save position if we actually dragged
			if (dragStarted) {
				localStorage.setItem('toc-position', JSON.stringify(currentPosition));
			}
			
			// Reset drag state after a short delay
			setTimeout(() => {
				isDragging = false;
				dragStarted = false;
			}, 100);
		}
		
		// Collect headings
		const headings = document.querySelectorAll('.prose h1, .prose h2, .prose h3, .prose h4, .prose h5, .prose h6');
		
		if (headings.length === 0) {
			tocTrigger.style.display = 'none';
			return;
		}
		
		// Generate TOC
		headings.forEach((heading, index) => {
			const headingElement = heading;
			
			// Generate ID if not exists
			if (!headingElement.id) {
				headingElement.id = `heading-${index}`;
			}
			
			const li = document.createElement('li');
			const a = document.createElement('a');
			
			a.href = `#${headingElement.id}`;
			a.textContent = headingElement.textContent || '';
			a.className = `toc-link toc-${headingElement.tagName.toLowerCase()}`;
			
			li.appendChild(a);
			tocList.appendChild(li);
		});
		
		// Toggle TOC visibility
		let isVisible = false;
		
		// Click handler for toggle
		tocTrigger.addEventListener('click', function(e) {
			e.stopPropagation();
			
			// Don't toggle if we just finished dragging
			if (dragStarted) return;
			
			isVisible = !isVisible;
			
			if (isVisible) {
				tocContainer.classList.add('visible');
				tocTrigger.classList.add('active');
			} else {
				tocContainer.classList.remove('visible');
				tocTrigger.classList.remove('active');
			}
		});
		
		// SIMPLIFIED: Remove all drag functionality for better reliability
		// Drag functionality removed to prevent positioning issues
		
		// Close TOC when clicking outside
		document.addEventListener('click', function(e) {
			const target = e.target;
			if (target && target instanceof Node && !tocContainer.contains(target) && !tocTrigger.contains(target)) {
				isVisible = false;
				tocContainer.classList.remove('visible');
				tocTrigger.classList.remove('active');
			}
		});
		
		// Prevent TOC from closing when clicking inside
		tocContainer.addEventListener('click', function(e) {
			e.stopPropagation();
		});
		
		// Active link highlighting
		const tocLinks = tocList.querySelectorAll('a');
		
		function updateActiveLink() {
			let currentHeading: HTMLElement | null = null;
			
			headings.forEach(heading => {
				const rect = heading.getBoundingClientRect();
				if (rect.top <= 120) {
					currentHeading = heading as HTMLElement;
				}
			});
			
			tocLinks.forEach(link => link.classList.remove('active'));
			
			if (currentHeading && tocList) {
				const headingId = (currentHeading as HTMLElement).id;
				if (headingId) {
					const activeLink = tocList.querySelector(`a[href="#${headingId}"]`);
					if (activeLink) {
						activeLink.classList.add('active');
					}
				}
			}
		}
		
		// Smooth scroll for links
		tocLinks.forEach(link => {
			link.addEventListener('click', function(e) {
				e.preventDefault();
				const href = this.getAttribute('href');
				if (href) {
					const targetId = href.slice(1);
					const targetElement = document.getElementById(targetId);
					
					if (targetElement) {
						const offsetTop = targetElement.offsetTop - 80;
						window.scrollTo({
							top: offsetTop,
							behavior: 'smooth'
						});
						
						// Close TOC after navigation on mobile
						if (window.innerWidth < 768) {
							isVisible = false;
							tocContainer.classList.remove('visible');
							tocTrigger.classList.remove('active');
						}
					}
				}
			});
		});
		
		// ESC key to close
		document.addEventListener('keydown', function(e) {
			if (e.key === 'Escape' && isVisible) {
				isVisible = false;
				tocContainer.classList.remove('visible');
				tocTrigger.classList.remove('active');
			}
		});
		
		// Throttled scroll listener
		let scrollTicking = false;
		window.addEventListener('scroll', function() {
			if (!scrollTicking) {
				requestAnimationFrame(function() {
					updateActiveLink();
					scrollTicking = false;
				});
				scrollTicking = true;
			}
		});
		
		// Window resize handler to keep button in viewport
		window.addEventListener('resize', function() {
			constrainToViewport();
			updateTriggerPosition();
		});
		
		// Initial active link
		updateActiveLink();
	});
</script> 